import { getBDDConfig } from '@/config';
import { json } from 'stream/consumers';

// Configuration for BDD framework - tells the generator what to create
export interface BDDConfig {
    framework: 'ocbc' | 'cucumber' | 'karate';  // Which testing framework to use
    language: 'java' | 'kotlin';                 // Programming language for generated code
    basePackage: string;                         // Java package name (e.g., com.ocbc.api)
    useLombok: boolean;                          // Use Lombok annotations for cleaner Java code
    generatePOJOs: boolean;                      // Create separate POJO files (we embed them in service classes)
    generateServiceClasses: boolean;             // Create service classes for API calls
    generateStepDefinitions: boolean;            // Create Cucumber step definitions
    generateFeatureFiles: boolean;               // Create Gherkin feature files
}

// Represents an API endpoint that we want to generate BDD code for
export interface Endpoint {
    method: string;                              // HTTP method (GET, POST, PUT, DELETE)
    path: string;                                // API path (e.g., /api/users)
    name: string;                                // Human-readable name for the endpoint
    description?: string;                        // What this endpoint does
    requestBody?: any;                           // JSON body for POST/PUT requests
    responseBody?: any;                          // Expected response data
    parameters?: Array<{                         // Query/path parameters
        name: string;                            // Parameter name
        type: string;                            // Data type (string, number, etc.)
        required: boolean;                       // Is this parameter required?
        description?: string;                    // What this parameter does
    }>;
    // Real API data from actual calls
    url?: string;                                // Full URL of the endpoint
    headers?: Record<string, string>;            // HTTP headers to send
    actualResponse?: {                           // Real response from API call
        status: number;                          // HTTP status code
        data: any;                               // Response body
        headers: Record<string, any>;            // Response headers
        responseTime: number;                    // How long the request took
    };
    validationRules?: Array<{                    // Rules to validate responses
        type: 'status' | 'value' | 'existence'; // What to validate
        field?: string;                          // Which field to check
        expectedValue?: string;                  // What value we expect
        condition?: 'equals' | 'not_equals' | 'contains' | 'starts_with' | 'ends_with' | 'is_empty' | 'is_not_empty' | 'is_null' | 'is_not_null';
    }>;
    // Which request body fields should be customizable in BDD scenarios
    customizableFields?: Set<string>;
    // Configuration for error scenario testing
    errorSchema?: {
        enabled: boolean;                        // Should we generate error test cases?
        statusCode: string;                      // Expected error status code
        errorStructure: string;                  // JSON structure of error response
    };
}

// The final output - all the generated BDD code files
export interface GeneratedCode {
    featureFiles: Array<{ name: string; content: string }>;      // Gherkin feature files (.feature)
    stepDefinitions: Array<{ name: string; content: string }>;   // Java step definition classes
    serviceClasses: Array<{ name: string; content: string }>;    // Java service classes for API calls
    pojos: Array<{ name: string; content: string }>;            // Java POJO classes (embedded in services)
}

export class BDDCodeGenerator {
    private config: BDDConfig;
    private openAPISpec: any = null; // Add OpenAPI spec property

    constructor(config?: BDDConfig) {
        this.config = config || getBDDConfig() as BDDConfig;
    }

    // Method to set OpenAPI specification
    public setOpenAPISpec(openAPISpec: any): void {
        this.openAPISpec = openAPISpec;
    }

    // Method to get extracted schemas from OpenAPI spec
    public getOpenAPISchemas(): Record<string, any> {
        if (!this.openAPISpec) {
            return {};
        }
        return this.extractOpenAPISchemas(this.openAPISpec);
    }

    // Main method - generates BDD code for all endpoints
    generateCode(endpoints: Endpoint[], config?: { endpointName?: string; basePackage?: string }): GeneratedCode {
        const result: GeneratedCode = {
            featureFiles: [],
            stepDefinitions: [],
            serviceClasses: [],
            pojos: [],
        };

        // Generate code for each endpoint
        for (const endpoint of endpoints) {
            // Use endpoint's own error schema if available, otherwise use global error schema
            const endpointWithErrorSchema = endpoint.errorSchema ? endpoint : endpoint;

            const endpointCode = this.generateEndpointCode(endpointWithErrorSchema, config);

            // Collect all generated files
            result.featureFiles.push(...endpointCode.featureFiles);
            result.stepDefinitions.push(...endpointCode.stepDefinitions);
            result.serviceClasses.push(...endpointCode.serviceClasses);
            // POJOs are now embedded in service classes, so we don't add them separately
        }

        return result;
    }

    // Generates all code files for a single endpoint
    private generateEndpointCode(endpoint: Endpoint, config?: { endpointName?: string; basePackage?: string }) {
        const className = this.generateClassName(endpoint, config?.endpointName);      // Java class name
        const featureName = this.generateFeatureName(endpoint.name, config?.endpointName);  // Feature file name

        return {
            featureFiles: [this.generateFeatureFile(endpoint, featureName)],           // Gherkin feature file
            stepDefinitions: [this.generateStepDefinitions(endpoint, className)],      // Cucumber steps
            serviceClasses: [this.generateServiceClass(endpoint, className)],          // API service class
            pojos: [], // POJOs are now embedded in service classes
        };
    }

    // Creates a valid Java class name from endpoint name
    private generateClassName(endpoint: Endpoint, endpointName?: string): string {
        const method = endpoint.method.toUpperCase();

        // Use custom endpointName if provided, otherwise extract from path
        let className: string;
        if (endpointName) {
            // Use the custom endpoint name and sanitize it
            className = this.sanitizeClassName(endpointName);
        } else {
            // Extract resource name from path and sanitize it
            const resource = this.getResourceFromPath(endpoint.path);
            className = this.sanitizeClassName(resource);
        }

        // Add method prefix for clarity
        if (method === 'GET') {
            className = `Get${className}`;
        } else if (method === 'POST') {
            className = `Post${className}`;
        } else if (method === 'PUT') {
            className = `Put${className}`;
        } else if (method === 'PATCH') {
            className = `Patch${className}`;
        } else if (method === 'DELETE') {
            className = `Delete${className}`;
        }

        // Add "Service" suffix
        className += 'Service';

        return className;
    }

    private sanitizeClassName(input: string): string {
        if (!input) return 'Default';

        // Remove invalid characters and convert to PascalCase
        return input
            // Replace dots, hyphens, underscores, and slashes with spaces
            .replace(/[.\-_\/]/g, ' ')
            // Remove any remaining special characters except letters, numbers, and spaces
            .replace(/[^a-zA-Z0-9\s]/g, '')
            // Split by spaces and capitalize each word
            .split(/\s+/)
            .filter(word => word.length > 0)
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join('');
    }

    private getResourceFromPath(path: string): string {
        if (!path) return 'Default';

        // Remove leading slash and split by slashes
        const cleanPath = path.startsWith('/') ? path.slice(1) : path;
        const parts = cleanPath.split('/').filter(part => part.length > 0);

        if (parts.length === 0) return 'Default';

        // Use the last meaningful part of the path
        let resource = parts[parts.length - 1];

        // Remove file extensions and query parameters
        resource = resource.split('.')[0];
        resource = resource.split('?')[0];

        // If it's empty or just numbers, use a parent path
        if (!resource || /^\d+$/.test(resource)) {
            resource = parts[parts.length - 2] || 'Default';
        }

        return resource;
    }

    /**
     * Generate POJO class for response schema
     */
    private generateResponsePOJO(endpoint: Endpoint, className: string): string {
        // Try to get schema from different sources
        const detectedSchema = this.detectSchemaFromSource(endpoint);
        let responseData: any = null;

        if (detectedSchema.source === 'openapi' && detectedSchema.response) {
            // Use OpenAPI schema
            responseData = this.convertSchemaToResponseData(detectedSchema.response);
        } else if (detectedSchema.source === 'inferred' && detectedSchema.response) {
            // Use inferred schema
            responseData = this.convertSchemaToResponseData(detectedSchema.response);
        } else {
            // Fallback to original logic
            responseData = endpoint.actualResponse?.data || endpoint.responseBody;
        }

        if (!responseData || Object.keys(responseData).length === 0) {
            return '';
        }

        const pojoClassName = `${className}ResponseData`;
        let pojoContent = `    // Response POJO for schema validation
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public static class ${pojoClassName} {
`;

        // Generate fields based on detected schema
        if (detectedSchema.source === 'openapi' && detectedSchema.response?.fields) {
            // Use OpenAPI schema fields
            detectedSchema.response.fields.forEach((field: any) => {
                const javaFieldName = this.generateJavaFieldName(field.name);
                const fieldType = field.type || 'String';
                const required = field.required ? 'true' : 'false';

                pojoContent += `        @JsonProperty(required = ${required})
        private ${fieldType} ${javaFieldName};
`;
            });
        } else {
            // Use original logic for backward compatibility
            for (const [fieldName, value] of Object.entries(responseData)) {
                const javaFieldName = this.generateJavaFieldName(fieldName);
                const fieldType = this.getJavaTypeForValue(value, fieldName, className);
                pojoContent += `        @JsonProperty(required = true)
        private ${fieldType} ${javaFieldName};
`;
            }
        }

        pojoContent += `    }`;

        // Generate nested POJOs for complex fields
        const nestedPOJOs = this.generateNestedPOJOs(responseData, detectedSchema, className);
        if (nestedPOJOs) {
            pojoContent += `\n${nestedPOJOs}`;
        }

        return pojoContent;
    }

    private getJavaTypeForValue(value: any, fieldName: string = '', className: string = ''): string {
        if (Array.isArray(value) && value.length > 0) {
            const firstItem = value[0];
            if (typeof firstItem === 'object' && firstItem !== null) {
                // Generate a proper class name for the array items based on field name and class
                const itemClassName = this.generateItemClassName(fieldName, className);
                return `List<${itemClassName}>`;
            }
            return `List<${this.getJavaType(typeof firstItem)}>`;
        }
        if (typeof value === 'object' && value !== null) {
            // For complex objects, generate a class name based on field name and class
            const objectClassName = this.generateObjectClassName(fieldName, className);
            return objectClassName;
        }
        return this.getJavaType(typeof value);
    }

    private generateItemClassName(fieldName: string, className: string): string {
        if (!fieldName) return `${className}Item`;

        // Convert field name to PascalCase and append to class name
        const fieldPascalCase = this.sanitizeClassName(fieldName);
        return `${className}${fieldPascalCase}`;
    }

    private generateObjectClassName(fieldName: string, className: string): string {
        if (!fieldName) return `${className}Data`;

        // Convert field name to PascalCase and append to class name
        const fieldPascalCase = this.sanitizeClassName(fieldName);
        return `${className}${fieldPascalCase}`;
    }

    private generateNestedPOJOs(responseData: any, detectedSchema: any, className: string): string {
        let nestedPOJOs = '';

        // Dynamically generate nested POJOs based on the actual data structure
        const processedFields = new Set<string>();

        const generateNestedClass = (data: any, fieldName: string, className: string, depth: number = 0): string => {
            if (depth > 3) return ''; // Prevent infinite recursion

            const classKey = `${className}_${fieldName}`;
            if (processedFields.has(classKey)) return '';
            processedFields.add(classKey);

            let classContent = `
    // ${className}${this.sanitizeClassName(fieldName)} structure
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ${className}${this.sanitizeClassName(fieldName)} {`;

            // Generate fields for this nested class
            Object.entries(data).forEach(([key, value]) => {
                const javaFieldName = this.generateJavaFieldName(key);
                const fieldType = this.getJavaTypeForValue(value, key, className);

                classContent += `
        @JsonProperty(required = true)
        private ${fieldType} ${javaFieldName};`;
            });

            classContent += `
    }`;

            // Recursively generate nested classes for complex fields
            Object.entries(data).forEach(([key, value]) => {
                if (this.isComplexField(value)) {
                    classContent += generateNestedClass(value, key, className, depth + 1);
                }
            });

            return classContent;
        };

        // Generate nested classes for complex fields in the main response
        Object.entries(responseData).forEach(([fieldName, value]) => {
            if (this.isComplexField(value)) {
                nestedPOJOs += generateNestedClass(value, fieldName, className, 0);
            }
            // Also check for nested structures in arrays
            if (Array.isArray(value) && value.length > 0 && this.isComplexField(value[0])) {
                nestedPOJOs += generateNestedClass(value[0], fieldName, className, 0);
            }
        });

        return nestedPOJOs;
    }

    /**
     * Generate POJO class for error schema
     */
    private generateErrorPOJO(endpoint: Endpoint, className: string): string {
        const errorStructure = endpoint.errorSchema?.errorStructure || '';

        const errorPojoClassName = `${className}ErrorData`;
        let errorPojoContent = `    // Error POJO for schema validation
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ${errorPojoClassName} {
`;

        // Parse error structure JSON and extract fields
        let errorFields: Array<{ name: string; type: string }> = [];
        if (errorStructure.trim()) {
            try {
                const parsedErrorStructure = JSON.parse(errorStructure);
                errorFields = this.extractFields(parsedErrorStructure);
            } catch (error) {
                // If JSON parsing fails, create default error fields
                errorFields = [
                    { name: 'error', type: 'string' },
                    { name: 'message', type: 'string' },
                    { name: 'statusCode', type: 'string' }
                ];
            }
        } else {
            // Default error fields if no structure provided
            errorFields = [
                { name: 'error', type: 'string' },
                { name: 'message', type: 'string' },
                { name: 'statusCode', type: 'string' }
            ];
        }

        // Add fields based on extracted error structure
        if (errorFields.length > 0) {
            errorFields.forEach(field => {
                const javaFieldName = this.generateJavaFieldName(field.name);
                const fieldType = this.getJavaType(field.type);
                // Default to required for error fields
                const required = 'true';
                errorPojoContent += `        @JsonProperty(required = ${required})
        private ${fieldType} ${javaFieldName};
`;
            });
        } else {
            // Fallback to basic error fields
            errorPojoContent += `        @JsonProperty(required = true)
        private String error;
        @JsonProperty(required = true)
        private String message;
        @JsonProperty(required = true)
        private String statusCode;
`;
        }

        errorPojoContent += `    }`;

        return errorPojoContent;
    }

    /**
     * Generate Java field name from JSON field name
     */
    private generateJavaFieldName(fieldName: string): string {
        // Convert camelCase or snake_case to camelCase
        return fieldName
            .replace(/[-_\s]+(.)/g, (_, char) => char.toUpperCase())
            .replace(/^(.)/, (_, char) => char.toLowerCase());
    }

    private generateFeatureName(name: string, endpointName?: string): string {
        // Use custom endpointName if provided, otherwise use the original name
        let nameToUse = endpointName || name;

        // Remove numeric suffixes and clean the name
        let cleanedName = nameToUse
            .replace(/\d+$/, '') // Remove trailing numbers
            .replace(/^\d+/, '') // Remove leading numbers
            .replace(/[-_\s]+/g, '_') // Replace multiple separators with underscore
            .toLowerCase()
            .trim();

        // If name is empty after cleaning, use a default
        if (!cleanedName) {
            cleanedName = 'api_endpoint';
        }

        return cleanedName;
    }

    private generateFeatureFile(endpoint: Endpoint, featureName: string) {
        const method = endpoint.method.toUpperCase();
        const path = endpoint.path;
        const description = endpoint.description || `${method} ${this.getResourceFromPath(path)}`;
        const resource = this.getResourceFromPath(path);
        const action = this.getActionFromMethod(method);

        // Use OCBC enterprise framework
        return this.generateOCBCFeatureFile(endpoint, featureName, description, method, resource, action);
    }

    private generateOCBCFeatureFile(endpoint: Endpoint, featureName: string, description: string, method: string, resource: string, action: string) {
        const responseData = endpoint.actualResponse?.data || endpoint.responseBody;
        const hasResponseData = responseData && Object.keys(responseData).length > 0;
        const hasValidationRules = endpoint.validationRules && endpoint.validationRules.length > 0;

        // Combine response data and validation rules for examples
        const exampleData = this.generateExampleData(endpoint, responseData);

        // Determine if this method requires a request body
        const requiresBody = ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase());

        // Get customizable fields for request body
        const customizableFields = endpoint.customizableFields || new Set();
        const hasCustomizableFields = requiresBody && customizableFields.size > 0;

        // let scenario = method.toLocaleUpperCase() === 'GET' ? 'Scenatio' : 'Scenario Outline';
    

        let content = `Feature: ${description}

Scenario Outline: Verify successful ${method} ${action} request to ${resource}
Given the user send for ${method} request to ${resource} service endpoint ${hasCustomizableFields ? `${ Array.from(customizableFields).map(field => `<${field}>`).join('') }` : ''}` 
   +`
Then the user should get status code for ${resource} endpoint as 200
${this.generateFeatureValidationSteps(endpoint)}
    Examples:
      |${this.generateExampleHeaders(exampleData)}|
      |${this.generateExampleValues(exampleData)}| 
`;



        // Add error scenario if error schema is enabled
        if (endpoint.errorSchema?.enabled) {

            // extract selected data
        const customizeData = this.generateCustomizeData(endpoint, responseData);

            
            content += `
Scenario Outline: Verify error response for ${method} ${action} request to ${resource}
${requiresBody ? `    Given the user send ${method} request to ${resource} service end point
${hasCustomizableFields ? `|action|fieldName${'|' + Array.from(customizableFields).map(field => `${field}`).join('|') + '|'}
|<action>|<fieldName>${'|' + Array.from(customizableFields).map(field => `<invalid_${field}>`).join('|') + '|'}` : ''}` : ''}
    Then the user should get status code for ${resource} endpoint as <errorCode>
    And the user verify the error schema of the response returned as expected for ${resource} service endpoint
    And the user verify the error response body should contain valid data for ${resource} service endpoint with <errorCode> and <errorMessage>
    Examples:
      |action|fieldName|${this.generateExampleHeaders(customizeData)}|errorCode|errorMessage|
      |remove or null or invalid|field to be modified|${this.generateExampleValues(customizeData)}|${endpoint.errorSchema.statusCode}|yourErrorMessage|
`;
        }

        return {
            name: `${featureName}.feature`,
            content,
        };
    }

    private generateStepDefinitions(endpoint: Endpoint, className: string) {
        const method = endpoint.method.toUpperCase();
        const resource = this.getResourceFromPath(endpoint.path);
        const requestClass = `${className}Request`;
        const responseClass = `${className}Response`;
        const serviceClass = `${className}Service`;

        // Use OCBC enterprise framework
        return this.generateOCBCStepDefinitions(endpoint, className, method, resource, requestClass, responseClass, serviceClass);
    }

    private generateOCBCStepDefinitions(endpoint: Endpoint, className: string, method: string, resource: string, requestClass: string, responseClass: string, serviceClass: string) {
        const resourceMethod = resource.toLowerCase().replace(/\s+/g, '_');
        const hasHeaders = endpoint.headers && Object.keys(endpoint.headers).length > 0;
        const headersMap = hasHeaders ? this.generateHeadersMap(endpoint.headers) : 'null';

        let getOrPostStep = `public void sendRequestToServiceEndpoint() throws JsonProcessingException, ParseException {`;

        // Determine if this method requires a request body
        const requiresBody = ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase());

        const content = `package ${this.config.basePackage}.steps;
        

import io.cucumber.java.en.*;
import io.restassured.response.Response;
import org.testng.Assert;
import org.json.simple.parser.ParseException;
import org.ocbcqa.core.report.Logger;
import org.ocbcqa.core.base.test.BaseStep;
import org.ocbcqa.core.util.CustomSoftAssert;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import com.fasterxml.jackson.core.JsonProcessingException;
import io.cucumber.datatable.DataTable;

import io.cucumber.java.en.Given;
import io.cucumber.java.en.When;
import io.cucumber.java.en.Then;
import static org.hamcrest.Matchers.*;
import java.util.HashMap;

import ${this.config.basePackage}.service.${serviceClass};${requiresBody ? `
import ${this.config.basePackage}.service.${serviceClass}.${requestClass};` : ''}
import ${this.config.basePackage}.service.${serviceClass}.${responseClass};

public class ${className}Steps {

    private static final Logger logger = LoggerFactory.getLogger(${className}Steps.class);
    private ${serviceClass} ${this.camelCase(serviceClass)} = new ${serviceClass}();
${requiresBody ? `    private ${requestClass} request;` : ''}
    private Response response;


    ${requiresBody ? this.generateDynamicRequestStep(endpoint, requestClass) : ''}    @When("I send a ${method} request ${requiresBody ? 'to body' : 'for ' + resourceMethod}")
    public void send${method}Request() {
${requiresBody ? `        response = ${this.camelCase(serviceClass)}.${method.toLowerCase()}("accessToken123", request);` : `        response = ${this.camelCase(serviceClass)}.${method.toLowerCase()}("tokenId123");`}
        // Store response in service for schema validation
        ${this.camelCase(serviceClass)}.setResponse(response);
    }

${endpoint.errorSchema?.enabled && requiresBody ? `
    @Given("Given the user send for ${method} request to ${resource} service endpoint")
    public void prepareInvalidPayload(${this.generateInvalidPayloadParameters(endpoint)}) {
        request = ${requestClass}.builder()
${this.generateInvalidPayloadBuilder(endpoint)}
                .build();
    }` : ''}


    @Then("the user should get status code for ${resource} endpoint as {int}")
    public void verifystatusCode(int expectedStatus) {
        assertEquals(response.getStatusCode(), expectedStatus);
    }

    @Then("the user verify the success schema of the response returned as expected for ${resource} service endpoint")
    public void verifySuccessSchema() {
        ${this.camelCase(resource)}.serializeSuccessResponse();
        ${this.camelCase(resource)}.validateSuccessResponseSchema();
    }

    @Then("the response should contain the correct ${resource} details")
    public void validate${className}Details(${this.generateValidationParameters(endpoint)}) {
        assertNotNull(response);
        // Get response data from POJO for validation
        ${className}ResponseData responseData = ${this.camelCase(serviceClass)}.getResponseData();
        assertNotNull(responseData, "Response data should not be null");
        ${this.generateValidationAssertions(endpoint)}
    }

    ${this.generateValidationSteps(endpoint)}


}`;

        return {
            name: `${className}Steps.java`,
            content,
        };
    }

    private generateServiceClass(endpoint: Endpoint, className: string) {
        const method = endpoint.method.toUpperCase();
        const resource = this.getResourceFromPath(endpoint.path);
        const requestClass = `${className}Request`;
        const responseClass = `${className}Response`;
        console.log("Value ====="+JSON.stringify(endpoint));        // Use OCBC enterprise framework with embedded POJOs
        return this.generateOCBCServiceClass(endpoint, className, method, resource, requestClass, responseClass);
    }

    private generateOCBCServiceClass(endpoint: Endpoint, className: string, method: string, resource: string, requestClass: string, responseClass: string) {
        const hasHeaders = endpoint.headers && Object.keys(endpoint.headers).length > 0;
        const headersMap = hasHeaders ? this.generateHeadersMap(endpoint.headers) : 'null';

        // Generate embedded POJOs
        const requestData = endpoint.requestBody ||
            (endpoint.actualResponse ? this.extractRequestDataFromResponse(endpoint) : this.generateDefaultRequestFields(endpoint));
        const responseData = endpoint.actualResponse?.data || endpoint.responseBody;

        // Only generate request POJO for methods that require a body
        const requiresBody = ['POST', 'PUT', 'PATCH'].includes(method.toUpperCase());
        const embeddedRequestPOJO = (requiresBody && requestData) || endpoint.method.toUpperCase() !== 'GET' ?
            this.generateEmbeddedPOJOClass(requestClass, requestData, true, endpoint) : '';
        const embeddedResponsePOJO = responseData ?
            this.generateEmbeddedPOJOClass(responseClass, responseData, false, endpoint) : '';

        // Generate response schema POJO for validation
        const responseSchemaPOJO = responseData ?
            this.generateResponsePOJO(endpoint, className) : '';

        // Generate error schema POJO if error schema is enabled
        const errorSchemaPOJO = endpoint.errorSchema?.enabled ?
            this.generateErrorPOJO(endpoint, className) : '';

        const content = `package ${this.config.basePackage}.service;

import io.restassured.response.Response;
import io.restassured.specification.RequestSpecification;
import io.restassured.http.Headers;
import io.restassured.http.Header;
import io.restassured.mapper.ObjectMapperType;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.Map;${this.config.useLombok ? `
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;` : ''}

public class ${className}Service extends BaseRestService {

    private URL hostAddress;
    private Map<String, String> customHeaders = ${headersMap};
    private Response response;

    public ${className}Service() {
        try {
            String appUrl = "appConfig.get("internetbanking", "msBaseUrl")";
            hostAddress = new URL(appUrl);
        } catch (MalformedURLException e) {
            throw new RuntimeException(e.getMessage());
        }
    }

    private List<Header> setupHeaders(String accessToken) {
        List<Header> headers = new ArrayList<>();
        
        // Add default Content-Type if no custom headers provided
        if (customHeaders == null || customHeaders.isEmpty()) {
            headers.add(new Header("Content-Type", "application/json"));
            System.out.println("No custom headers provided, using default Content-Type");
        } else {
            // Add all custom headers from frontend
            System.out.println("Adding custom headers from frontend:");
            for (Map.Entry<String, String> entry : customHeaders.entrySet()) {
                Header header = new Header(entry.getKey(), entry.getValue());
                headers.add(header);
                System.out.println("  - " + entry.getKey() + ": " + entry.getValue());
            }
        }
        
        System.out.println("Total headers created: " + headers.size());
        return headers;
    }

    private String generateCorrelationId() {
        return UUID.randomUUID().toString();
    }

    // Method for requests that require a body (POST, PUT, PATCH)
    public Response ${method.toLowerCase()}(String accessToken, ${requestClass} requestBody) {
        List<Header> headers = setupHeaders(accessToken);
        RequestSpecification requestSpecification = baseRequestSpec()
                .headers(new Headers(headers))
                .body(requestBody, ObjectMapperType.GSON);
        this.response = ${method.toLowerCase()}(requestSpecification, hostAddress.toString());
        return this.response;
    }

${method.toUpperCase() === 'GET' ? `
    // Method for GET requests that don't require a body
    public Response ${method.toLowerCase()}(String tokenId) {
        RequestSpecification requestSpecification = baseRequestSpec()
                .headers(new Headers(setupHeaders(tokenId)));
        Response response = ${method.toLowerCase()}(requestSpecification, hostAddress.toString());
        return response;
    }` : ''}

    public Response ${method.toLowerCase()}(String accessToken, ${requestClass} requestBody, String endPointURL) {
        List<Header> headers = setupHeaders(accessToken);
        RequestSpecification requestSpecification = baseRequestSpec()
                .headers(new Headers(headers))
                .body(requestBody, ObjectMapperType.GSON);
        this.response = ${method.toLowerCase()}(requestSpecification, endPointURL);
        return this.response;
    }

${method.toUpperCase() === 'GET' ? `
    // Method for GET requests with custom endpoint URL
    public Response ${method.toLowerCase()}(String tokenId, String endPointURL) {
        RequestSpecification requestSpecification = baseRequestSpec()
                .headers(new Headers(setupHeaders(tokenId)));
        Response response = ${method.toLowerCase()}(requestSpecification, endPointURL);
        return response;
    }` : ''}

    // Error schema validation methods
${endpoint.errorSchema?.enabled ? `
    // Error schema validation method
    public void validateErrorSchema() {
        // This method validates error responses against the error schema
        if (response == null) {
            throw new RuntimeException("Error response is null");
        }
        if (response.getStatusCode() != ${endpoint.errorSchema.statusCode}) {
            throw new RuntimeException("Expected error status ${endpoint.errorSchema.statusCode}, but got " + response.getStatusCode());
        }
        if (response.getBody() == null) {
            throw new RuntimeException("Error response body is null");
        }
        
        // ✅ NOW VALIDATES AGAINST PostApiUsersErrorData POJO SCHEMA
        try {
            ${className}ErrorData errorData = response.getBody().as(${className}ErrorData.class, ObjectMapperType.GSON);
            if (errorData == null) {
                throw new RuntimeException("Failed to deserialize error response to ${className}ErrorData");
            }
            
            // ✅ VALIDATION PASSES ONLY IF ERROR RESPONSE MATCHES POJO SCHEMA
            System.out.println("Error response schema validation successful - response matches ${className}ErrorData schema");
        } catch (Exception e) {
            throw new RuntimeException("Error response schema validation failed: " + e.getMessage());
        }
    }

    // Helper method to get error response data
    public ${className}ErrorData getErrorResponseData() {
        return response.getBody().as(${className}ErrorData.class, ObjectMapperType.GSON);
    }` : ''}

    // Method to set response (called from step definitions)
    public void setResponse(Response response) {
        this.response = response;
    }

    // Success schema validation method
    public void validateSuccessSchema() {
        // This method validates success responses against the success schema
        if (response == null) {
            throw new RuntimeException("Response is null");
        }
        if (response.getBody() == null) {
            throw new RuntimeException("Response body is null");
        }
        
        // Validate response against the generated POJO schema
        try {
            ${className}ResponseData responseData = response.getBody().as(${className}ResponseData.class, ObjectMapperType.GSON);
            if (responseData == null) {
                throw new RuntimeException("Failed to deserialize response to ${className}ResponseData");
            }
            
            // Basic validation passed - response successfully deserialized to POJO
            System.out.println("Response schema validation successful - response matches ${className}ResponseData schema");
        } catch (Exception e) {
            throw new RuntimeException("Response schema validation failed: " + e.getMessage());
        }
    }

    // Helper method to get response data from POJO
    public ${className}ResponseData getResponseData() {
        if (response == null) {
            throw new RuntimeException("Response is null");
        }
        return response.getBody().as(${className}ResponseData.class, ObjectMapperType.GSON);
    }

    // Embedded POJO Classes
${embeddedRequestPOJO}
${embeddedResponsePOJO}
${responseSchemaPOJO}
${errorSchemaPOJO}
}`;

        return {
            name: `${className}Service.java`,
            content,
        };
    }

    private generateEmbeddedPOJOClass(className: string, data: any, isRequest: boolean, endpoint?: Endpoint): string {
        if (!data) return '';

        let fields: any[] = [];

        // Try to use detected schema if available
        if (endpoint) {
            const detectedSchema = this.detectSchemaFromSource(endpoint);
            if (detectedSchema.source === 'openapi' && detectedSchema.request && isRequest) {
                fields = detectedSchema.request.fields || [];
            } else if (detectedSchema.source === 'openapi' && detectedSchema.response && !isRequest) {
                fields = detectedSchema.response.fields || [];
            } else if (detectedSchema.source === 'inferred') {
                fields = isRequest ? (detectedSchema.request?.fields || []) : (detectedSchema.response?.fields || []);
            }
        }

        // Fallback to original logic if no schema detected
        if (fields.length === 0) {
            fields = this.extractFields(data);
        }

        if (fields.length === 0) return '';

        const lombokImports = this.config.useLombok ? `
import lombok.Data;
import lombok.Builder;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;` : '';

        const lombokAnnotations = this.config.useLombok ?
            `@Data${isRequest ? '\n@Builder' : ''}
@NoArgsConstructor
@AllArgsConstructor` : '';

        const fieldsCode = fields.map(field => {
            const fieldType = field.type || this.getJavaType(field.type);
            const fieldName = field.name;
            const annotation = this.config.useLombok ? '' : `
        @JsonProperty("${fieldName}")
        private ${fieldType} ${this.camelCase(fieldName)};`;

            return this.config.useLombok ?
                `        private ${fieldType} ${this.camelCase(fieldName)};` :
                annotation;
        }).join('\n');

        const gettersSetters = this.config.useLombok ? '' : this.generateGettersSetters(fields);

        return `${lombokAnnotations}
    public static class ${className} {
${fieldsCode}${gettersSetters}
    }`;
    }

    private generatePOJOs(endpoint: Endpoint, className: string) {
        // POJOs are now embedded in service classes, so return empty array
        return [];
    }

    private extractRequestDataFromResponse(endpoint: Endpoint): any {
        // Try to extract request data from the actual API call
        if (endpoint.actualResponse?.data) {
            // For POST/PUT requests, the response might contain the created/updated object
            // which can give us clues about the request structure
            return this.inferRequestStructureFromResponse(endpoint.actualResponse.data);
        }
        return this.generateDefaultRequestFields(endpoint);
    }

    private inferRequestStructureFromResponse(responseData: any): any {
        // Infer request structure from response data
        // This is a simple heuristic - in practice, you might want more sophisticated logic
        if (typeof responseData === 'object' && responseData !== null) {
            const inferredRequest: any = {};

            // Common patterns: if response has id, name, email, etc., request likely has similar fields
            if (responseData.id !== undefined) {
                // Don't include id in request (it's usually generated)
            }
            if (responseData.name !== undefined) {
                inferredRequest.name = "string";
            }
            if (responseData.email !== undefined) {
                inferredRequest.email = "string";
            }
            if (responseData.age !== undefined) {
                inferredRequest.age = "number";
            }
            if (responseData.description !== undefined) {
                inferredRequest.description = "string";
            }

            return Object.keys(inferredRequest).length > 0 ? inferredRequest : null;
        }
        return null;
    }

    private extractFields(data: any): Array<{ name: string; type: string }> {
        if (!data || typeof data !== 'object') {
            return [];
        }

        return Object.entries(data).map(([key, value]) => ({
            name: key,
            type: this.getJavaType(typeof value),
        }));
    }

    private getJavaType(jsType: string): string {
        console.log("JS Type ::: " + jsType)
        switch (jsType) {
            case 'string':
                return 'String';
            case 'number':
                return 'Integer';
            case 'boolean':
                return 'Boolean';
            case 'object':
                return 'Object';
            default:
                return 'String';
        }
    }

    private generateGettersSetters(fields: Array<{ name: string; type: string }>): string {
        return fields.map(field => {
            const fieldName = this.camelCase(field.name);
            const fieldType = field.type;
            const getterName = field.type === 'Boolean' ? `is${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)}` : `get${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)}`;
            const setterName = `set${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)}`;

            return `

        public ${fieldType} ${getterName}() {
            return ${fieldName};
        }

        public void ${setterName}(${fieldType} ${fieldName}) {
            this.${fieldName} = ${fieldName};
        }`;
        }).join('');
    }

    private generateRequestBuilder(endpoint: Endpoint): string {
        // Only generate builder for methods that require a request body
        const requiresBody = ['POST', 'PUT', 'PATCH'].includes(endpoint.method.toUpperCase());
        if (!requiresBody) {
            return '';
        }

        if (!endpoint.requestBody) {
            return this.generateDefaultRequestBuilder(endpoint);
        }

        return Object.entries(endpoint.requestBody).map(([key, value]) => {
            const fieldName = this.camelCase(key);
            const fieldValue = typeof value === 'string' ? `"${value}"` : value;
            return `                .${fieldName}(${fieldValue})`;
        }).join('\n');
    }



    private generateResponseAssertions(endpoint: Endpoint): string {
        const responseData = endpoint.actualResponse?.data || endpoint.responseBody;
        if (!responseData) {
            return '// Add specific assertions based on your response structure';
        }

        return Object.entries(responseData).map(([key, value]) => {
            const fieldName = this.camelCase(key);
            const parameterName = fieldName.toLowerCase();
            return `        assertEquals(response.get${fieldName.charAt(0).toUpperCase() + fieldName.slice(1)}(), ${parameterName});`;
        }).join('\n');
    }

    private generateResponseParameters(endpoint: Endpoint): string {
        const responseData = endpoint.actualResponse?.data || endpoint.responseBody;
        if (!responseData) {
            return '';
        }

        return Object.entries(responseData).map(([key, value]) => {
            const fieldName = this.camelCase(key);
            const fieldType = this.getJavaType(typeof value);
            const parameterName = fieldName.toLowerCase();
            return `${fieldType} ${parameterName}`;
        }).join(', ');
    }

    private generateValidationParameters(endpoint: Endpoint): string {
        const parameters: string[] = [];

        // Add parameters for validation rules only
        if (endpoint.validationRules) {
            endpoint.validationRules.forEach(rule => {
                if (rule.type === 'value' && rule.field) {
                    // Handle both simple field names and JSON paths
                    let fieldName = rule.field;

                    // If it's a JSON path, extract the last part
                    if (fieldName.includes('.')) {
                        fieldName = fieldName.split('.').pop() || fieldName;
                    }

                    const camelCaseFieldName = this.camelCase(fieldName);
                    const fieldType = this.getJavaType(typeof rule.expectedValue || 'string');
                    const parameterName = camelCaseFieldName.toLowerCase();
                    parameters.push(`${fieldType} ${parameterName}`);
                }
            });
        }

        return parameters.join(', ');
    }

    private generateValidationAssertions(endpoint: Endpoint): string {
        const assertions: string[] = [];

        // Add assertions for validation rules only
        if (endpoint.validationRules) {
            endpoint.validationRules.forEach(rule => {
                if (rule.type === 'value' && rule.field) {
                    // Handle both simple field names and JSON paths
                    let fieldName = rule.field;

                    // If it's a JSON path, extract the last part
                    if (fieldName.includes('.')) {
                        fieldName = fieldName.split('.').pop() || fieldName;
                    }

                    const camelCaseFieldName = this.camelCase(fieldName);
                    const parameterName = camelCaseFieldName.toLowerCase();
                    assertions.push(`        assertEquals(response.jsonPath().get("${fieldName}"), ${parameterName});`);
                } else if (rule.type === 'existence' && rule.field) {
                    // Handle both simple field names and JSON paths
                    let fieldName = rule.field;

                    // If it's a JSON path, extract the last part
                    if (fieldName.includes('.')) {
                        fieldName = fieldName.split('.').pop() || fieldName;
                    }

                    const camelCaseFieldName = this.camelCase(fieldName);
                    const condition = rule.condition || 'is_not_empty';
                    assertions.push(`        assertThat(response.jsonPath().get("${fieldName}"), ${this.getExistenceAssertionMethod(condition)}());`);
                }
            });
        }

        return assertions.join('\n');
    }

    private generateResponseExampleHeaders(responseData: any): string {
        return Object.keys(responseData).map(key => {
            const fieldName = this.camelCase(key);
            return fieldName.toLowerCase();
        }).join(' | ');
    }

    private generateResponseExampleValues(responseData: any): string {
        return Object.entries(responseData).map(([key, value]) => {
            // Status codes should be integers without quotes
            if (key === 'expected_status') {
                return value.toString();
            }
            // String values should have quotes
            else if (typeof value === 'string') {
                return `"${value}"`;
            }
            // Numbers and booleans should not have quotes
            else if (typeof value === 'number') {
                return value.toString();
            } else if (typeof value === 'boolean') {
                return value.toString();
            } else {
                return '""';
            }
        }).join(' | ');
    }

    private generateExampleData(endpoint: Endpoint, responseData: any): any {
        const exampleData: any = {};

        // Add expected status code as number
        exampleData.expected_status = this.getExpectedStatus(endpoint.method);

        // Add request body fields for POST/PUT/PATCH methods
        const requiresBody = ['POST', 'PUT', 'PATCH'].includes(endpoint.method.toUpperCase());
        if (requiresBody && endpoint.requestBody) {
            // Only include fields that are marked as customizable
            const customizableFields = endpoint.customizableFields || new Set();

            Object.keys(endpoint.requestBody).forEach(field => {
                // Only add to Examples if field is customizable
                if (customizableFields.has(field)) {
                    const fieldValue = endpoint.requestBody[field];
                    if (typeof fieldValue === 'string') {
                        exampleData[field] = fieldValue;
                    } else if (typeof fieldValue === 'number') {
                        exampleData[field] = fieldValue;
                    } else if (typeof fieldValue === 'boolean') {
                        exampleData[field] = fieldValue;
                    } else {
                        exampleData[field] = '""';
                    }
                }
            });
        }

        // Add validation rule values only
        if (endpoint.validationRules) {
            endpoint.validationRules.forEach(rule => {
                if (rule.type === 'status') {
                    // Ensure status is always a number
                    const statusValue = rule.expectedValue || this.getExpectedStatus(endpoint.method);
                    exampleData.expected_status = typeof statusValue === 'string' ? parseInt(statusValue) : statusValue;
                } else if (rule.type === 'value' && rule.field) {
                    // Handle both simple field names and JSON paths
                    let fieldName = rule.field.toLowerCase();

                    // If it's a JSON path, extract the last part
                    if (fieldName.includes('.')) {
                        fieldName = fieldName.split('.').pop() || fieldName;
                    }

                    // Use expectedValue if provided, otherwise use a placeholder
                    exampleData[fieldName] = rule.expectedValue || '""';
                } else if (rule.type === 'existence' && rule.field) {
                    // Handle both simple field names and JSON paths
                    let fieldName = rule.field.toLowerCase();

                    // If it's a JSON path, extract the last part
                    if (fieldName.includes('.')) {
                        fieldName = fieldName.split('.').pop() || fieldName;
                    }

                    // For existence rules, we don't need example values, but we need the field in headers
                    exampleData[fieldName] = '""';
                }
            });
        }

        return exampleData;
    }

    private generateCustomizeData(endpoint: Endpoint, responseData: any): any {
        const exampleData: any = {};


        // Add request body fields for POST/PUT/PATCH methods
        const requiresBody = ['POST', 'PUT', 'PATCH'].includes(endpoint.method.toUpperCase());
        if (requiresBody && endpoint.requestBody) {
            // Only include fields that are marked as customizable
            const customizableFields = endpoint.customizableFields || new Set();

            Object.keys(endpoint.requestBody).forEach(field => {
                // Only add to Examples if field is customizable
                if (customizableFields.has(field)) {
                    const value = endpoint.requestBody[field];
                    exampleData[field] = ['string', 'number', 'boolean'].includes(typeof value)
                        ? value
                        : '""';
                }
            });
        }


        return exampleData;
    }

    private generateExampleHeaders(exampleData: any): string {
        return Object.keys(exampleData).join('|');
    }

    private generateExampleValues(exampleData: any): string {
        return Object.entries(exampleData).map(([key, value]) => {
            if (typeof value === 'string') {
                return `"${value}"`;
            } else if (typeof value === 'number') {
                return value.toString();
            } else if (typeof value === 'boolean') {
                return value.toString();
            } else {
                return '""';
            }
        }).join('|');
    }

    private generateFeatureValidationSteps(endpoint: Endpoint): string {
        const steps: string[] = [];

        // Always add status code step
        steps.push('    Then the response status code should be <expected_status>');

        // Add schema validation step if response data exists
        const responseData = endpoint.actualResponse?.data || endpoint.responseBody;
        if (responseData && Object.keys(responseData).length > 0) {
            steps.push('    And the response should match the success response schema');
        }

        // Add steps for each validation rule using parameterized steps
        if (endpoint.validationRules) {
            endpoint.validationRules.forEach(rule => {
                if (rule.type === 'status') {
                    // Status code is already handled above
                    return;
                } else if (rule.type === 'value' && rule.field) {
                    // Use parameterized step for field validation
                    let fieldName = rule.field;

                    // If it's a JSON path, extract the last part for the parameter name
                    let paramName = fieldName;
                    if (fieldName.includes('.')) {
                        paramName = fieldName.split('.').pop() || fieldName;
                    }

                    steps.push(`    And the response field "${fieldName}" should equals <${paramName}>`);
                } else if (rule.type === 'existence' && rule.field) {
                    let fieldName = rule.field;

                    // If it's a JSON path, extract the last part for the parameter name
                    let paramName = fieldName;
                    if (fieldName.includes('.')) {
                        paramName = fieldName.split('.').pop() || fieldName;
                    }

                    const condition = rule.condition || 'is_not_empty';

                    if (condition === 'is_not_empty') {
                        steps.push(`    And the response field "${fieldName}" should not be empty`);
                    } else if (condition === 'is_empty') {
                        steps.push(`    And the response field "${fieldName}" should be empty`);
                    } else if (condition === 'is_not_null') {
                        steps.push(`    And the response field "${fieldName}" should not be null`);
                    } else if (condition === 'is_null') {
                        steps.push(`    And the response field "${fieldName}" should be null`);
                    } else {
                        steps.push(`    And the response field "${fieldName}" should ${condition}`);
                    }
                } else {
                    // Rule not processed
                }
            });
        }

        return steps.join('\n');
    }
    

    private generateValidationSteps(endpoint: Endpoint): string {
        let steps = '';

        // Add success schema validation step if response data exists
        const responseData = endpoint.actualResponse?.data || endpoint.responseBody;
        if (responseData && Object.keys(responseData).length > 0) {

            const className = this.generateClassName(endpoint);
            const serviceClass = `${className}Service`;
            steps += `
    @Then("the response should match the success response schema")
    public void validateResponseSchema() {
        // Validate response against generated POJO schema using service
        ${this.camelCase(serviceClass)}.validateSuccessSchema();
        logger.info("Response schema validation successful");
    }`;
        }

        // Add error schema validation steps if error schema is enabled
        if (endpoint.errorSchema?.enabled) {
            const className = this.generateClassName(endpoint);
            const serviceClass = `${className}Service`;
            steps += `
    @Then("the response should match the error response schema")
    public void validateErrorResponseSchema() {
        // Validate error response against generated error POJO schema using service
        ${this.camelCase(serviceClass)}.validateErrorSchema();
        logger.info("Error response schema validation successful");
    }`;


        }

        if (!endpoint.validationRules || endpoint.validationRules.length === 0) {
            return steps;
        }

        // Only generate the validation steps that are actually used in the feature file
        const usedSteps = new Set<string>();

        // Add status validation step (always used)
        usedSteps.add('status');

        // Add steps based on actual validation rules
        endpoint.validationRules.forEach(rule => {
            if (rule.type === 'value' && rule.field) {
                usedSteps.add('field_equals');
            } else if (rule.type === 'existence' && rule.field) {
                const condition = rule.condition || 'is_not_empty';
                if (condition === 'is_not_empty') {
                    usedSteps.add('field_not_empty');
                } else if (condition === 'is_empty') {
                    usedSteps.add('field_empty');
                } else if (condition === 'is_not_null') {
                    usedSteps.add('field_not_null');
                } else if (condition === 'is_null') {
                    usedSteps.add('field_null');
                }
            }
        });


        // Only add steps that are actually used
        if (usedSteps.has('status')) {
            steps += `
    @Then("^the response status should be (.+)$")
    public void validateResponseStatus(String expectedStatus) {
        assertEquals(response.getStatusCode(), Integer.parseInt(expectedStatus));
    }`;
        }

        if (usedSteps.has('field_equals')) {
            const className = this.generateClassName(endpoint);
            const fields = Object.keys(responseData);
            const serviceClass = `${className}Service`;
            steps += `
    @Then("^the response field (.+) should equals (.+)$")
    public void validateResponseField(String fieldName, String expectedValue) {
        // Get response data from POJO for validation
        ${className}ResponseData responseData = ${this.camelCase(serviceClass)}.getResponseData();
        assertNotNull(responseData, "Response data should not be null");
        
        // Validate field value using POJO getter methods
        switch (fieldName) {
            ${fields.map(field => {
    return `case ${field}:
                assertEquals(responseData.get${this.pojoMethodCase(field)}(), expectedValue);
                break;
            `
        }).join('')}default:
                throw new IllegalArgumentException("Unknown field: " + fieldName);
        }
    }`;
        }
        

        if (usedSteps.has('field_not_empty')) {
            const className = this.generateClassName(endpoint);
            const serviceClass = `${className}Service`;
            steps += `
    @Then("^the response field (.+) should not be empty$")
    public void validateResponseFieldNotEmpty(String fieldName) {
        // Get response data from POJO for validation
        ${className}ResponseData responseData = ${this.camelCase(serviceClass)}.getResponseData();
        assertNotNull(responseData, "Response data should not be null");
        
        // Validate field is not empty using POJO getter methods
        switch (fieldName) {
            case "name":
                assertNotNull(responseData.getName(), "Name should not be null");
                assertFalse(responseData.getName().isEmpty(), "Name should not be empty");
                break;
            case "job":
                assertNotNull(responseData.getJob(), "Job should not be null");
                assertFalse(responseData.getJob().isEmpty(), "Job should not be empty");
                break;
            case "id":
                assertNotNull(responseData.getId(), "ID should not be null");
                assertFalse(responseData.getId().isEmpty(), "ID should not be empty");
                break;
            case "createdAt":
                assertNotNull(responseData.getCreatedAt(), "CreatedAt should not be null");
                assertFalse(responseData.getCreatedAt().isEmpty(), "CreatedAt should not be empty");
                break;
            default:
                throw new IllegalArgumentException("Unknown field: " + fieldName);
        }
    }`;
        }

        if (usedSteps.has('field_empty')) {
            steps += `
    @Then("^the response field (.+) should be empty$")
    public void validateResponseFieldEmpty(String fieldName) {
        assertThat(response.jsonPath().get(fieldName), isEmpty());
    }`;
        }

        if (usedSteps.has('field_not_null')) {
            steps += `
    @Then("^the response field (.+) should not be null$")
    public void validateResponseFieldNotNull(String fieldName) {
        assertThat(response.jsonPath().get(fieldName), isNotNull());
    }`;
        }

        if (usedSteps.has('field_null')) {
            steps += `
    @Then("^the response field (.+) should be null$")
    public void validateResponseFieldNull(String fieldName) {
        assertThat(response.jsonPath().get(fieldName), isNull());
    }`;
        }

        return steps;
    }

    private generateValidationStepName(rule: any): string {
        switch (rule.type) {
            case 'status':
                return `the response status should be ${rule.expectedValue || '200'}`;
            case 'value':
                const condition = rule.condition || 'equals';
                return `the response field "${rule.field}" should ${condition} "${rule.expectedValue}"`;
            case 'existence':
                const existenceCondition = rule.condition || 'is_not_empty';
                return `the response field "${rule.field}" should ${existenceCondition}`;
            default:
                return `the response should match validation rule "${rule.type}"`;
        }
    }

    private generateValidationAssertion(rule: any): string {
        switch (rule.type) {
            case 'status':
                return `assertEquals(response.getStatusCode(), ${rule.expectedValue || '200'});`;
            case 'value':
                const condition = rule.condition || 'equals';
                const fieldPath = rule.field?.split('.').join('().') || 'data';
                return `assertThat(response.jsonPath().get("${fieldPath}"), ${this.getAssertionMethod(condition)}("${rule.expectedValue}"));`;
            case 'existence':
                const existenceCondition = rule.condition || 'is_not_empty';
                const fieldPath2 = rule.field?.split('.').join('().') || 'data';
                return `assertThat(response.jsonPath().get("${fieldPath2}"), ${this.getExistenceAssertionMethod(existenceCondition)}());`;
            default:
                return `// Custom validation for ${rule.type}`;
        }
    }

    private getAssertionMethod(condition: string): string {
        switch (condition) {
            case 'equals':
                return 'is';
            case 'not_equals':
                return 'isNot';
            case 'contains':
                return 'containsString';
            case 'starts_with':
                return 'startsWith';
            case 'ends_with':
                return 'endsWith';
            default:
                return 'is';
        }
    }

    private getExistenceAssertionMethod(condition: string): string {
        switch (condition) {
            case 'is_empty':
                return 'isEmpty';
            case 'is_not_empty':
                return 'isNotEmpty';
            case 'is_null':
                return 'isNull';
            case 'is_not_null':
                return 'isNotNull';
            default:
                return 'isNotEmpty';
        }
    }

    private generateDefaultRequestFields(endpoint: Endpoint): any {
        // Only generate default fields for methods that require a request body
        const requiresBody = ['POST', 'PUT', 'PATCH'].includes(endpoint.method.toUpperCase());
        if (!requiresBody) {
            return null;
        }

        // Generate default fields based on endpoint path
        const resource = this.getResourceFromPath(endpoint.path);
        return {
            id: 1,
            name: "Test Name",
            email: "test@example.com",
        };
    }

    private generateDefaultRequestBuilder(endpoint: Endpoint): string {
        // Only generate builder for methods that require a request body
        const requiresBody = ['POST', 'PUT', 'PATCH'].includes(endpoint.method.toUpperCase());
        if (!requiresBody) {
            return '';
        }

        const resource = this.getResourceFromPath(endpoint.path);
        return `                .name("Test ${resource}")
                 .email("test@example.com")`;
    }

    private generateDynamicRequestStep(endpoint: Endpoint, requestClass: string): string {
        if (!endpoint.requestBody || Object.keys(endpoint.requestBody).length === 0) {
            return '';
        }

        const customizableFields = endpoint.customizableFields || new Set();
        const allFields = Object.keys(endpoint.requestBody);

        var regexFields = ''; 
        
        // Parameters for customizable fields only
        const parameters = allFields
            .filter(field => customizableFields.has(field))
            .map(field => { 
                regexFields +='(.+)'; 
                return this.getJavaType(typeof endpoint.requestBody[field]) +` ${field}`;
            })
            .join(', ');
             console.log("allfields-----"+JSON.stringify(allFields))
                console.log("customizableFields-----"+JSON.stringify(customizableFields))
            console.log("params-----"+JSON.stringify(parameters))

        // Builder calls for all fields (customizable use parameters, others use defaults)
        const builderCalls = allFields.map(field => {
            if (customizableFields.has(field)) {
                return `.${field}(${field})`; // Use parameter
            } else {
                // Use default value from request body
                const defaultValue = endpoint.requestBody[field];
                if (typeof defaultValue === 'string') {
                    return `.${field}("${defaultValue}")`;
                } else {
                    return `.${field}(${defaultValue})`;
                }
            }
        }).join('\n                ');

        // Always generate step for POST/PUT/PATCH requests, even if no customizable fields
        if (customizableFields.size === 0) {
            // No customizable fields - use all defaults
            return `    @Given("I prepare a valid payload for ${endpoint.method}")
     public void prepareValidPayload() {
         request = ${requestClass}.builder()
                 ${builderCalls}
                 .build();
     }

`;
        }

        return `    @Given("I prepare a valid payload for ${endpoint.method} with the following data: ${regexFields}")
     public void prepareValidPayload(${parameters}) {
         request = ${requestClass}.builder()
                 ${builderCalls}
                 .build();
     }

`;
    }

    private generateInvalidPayloadParameters(endpoint: Endpoint): string {
        const parameters: string[] = [];
        const customizableFields = endpoint.customizableFields || new Set();
        const allFields = Object.keys(endpoint.requestBody || {});

        allFields.forEach(field => {
            if (customizableFields.has(field)) {
                parameters.push(`String ${field}`);
            }
        });
        return parameters.join(', ');
    }

    private generateInvalidPayloadBuilder(endpoint: Endpoint): string {
        const builderCalls: string[] = [];
        const customizableFields = endpoint.customizableFields || new Set();
        const allFields = Object.keys(endpoint.requestBody || {});

        allFields.forEach(field => {
            if (customizableFields.has(field)) {
                builderCalls.push(`                .${field}(${field})`);
            } else {
                // Use default values for non-customizable fields
                const defaultValue = endpoint.requestBody?.[field];
                if (typeof defaultValue === 'string') {
                    builderCalls.push(`                .${field}("${defaultValue}")`);
                } else {
                    builderCalls.push(`                .${field}(${defaultValue})`);
                }
            }
        });
        return builderCalls.join('\n');
    }

    // Helper methods
    private getTagFromPath(path: string): string {
        const parts = path.split('/').filter(p => p);
        return parts[0] || 'api';
    }

    private getActionFromMethod(method: string): string {
        switch (method) {
            case 'GET':
                return 'get';
            case 'POST':
                return 'create';
            case 'PUT':
                return 'update';
            case 'DELETE':
                return 'delete';
            case 'PATCH':
                return 'patch';
            default:
                return 'process';
        }
    }

    private getExpectedStatus(method: string): number {
        switch (method) {
            case 'GET':
                return 200;
            case 'POST':
                return 201;
            case 'PUT':
                return 200;
            case 'DELETE':
                return 204;
            case 'PATCH':
                return 200;
            default:
                return 200;
        }
    }

    private getMethodName(method: string, resource: string): string {
        const action = this.getActionFromMethod(method);
        return `${action}${resource.charAt(0).toUpperCase() + resource.slice(1)}`;
    }

    private camelCase(str: string): string {
        return str.charAt(0).toLowerCase() + str.slice(1);
    }

    private pojoMethodCase(str: string): string {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    private generateHeadersMap(headers: Record<string, string>): string {

        if (!headers || Object.keys(headers).length === 0) {
            return 'null';
        }

        const headerEntries = Object.entries(headers)
            .map(([key, value]) => `put("${key}", "${value}");`)
            .join('\n                ');


        return `new HashMap<String, String>() {{
                ${headerEntries}
            }}`;
    }

    // OpenAPI Schema Extraction Methods
    private extractOpenAPISchemas(openAPISpec: any): Record<string, any> {
        const schemas: Record<string, any> = {};

        try {
            // Extract component schemas
            if (openAPISpec.components?.schemas) {
                Object.entries(openAPISpec.components.schemas).forEach(([name, schema]) => {
                    schemas[name] = this.convertOpenAPISchemaToPOJO(schema);
                });
            }

            // Extract request/response schemas from paths
            if (openAPISpec.paths) {
                Object.entries(openAPISpec.paths).forEach(([path, operations]) => {
                    Object.entries(operations as any).forEach(([method, operation]) => {
                        if (method === 'get' || method === 'post' || method === 'put' || method === 'patch' || method === 'delete') {
                            const operationData = operation as any;

                            // Extract request schema
                            if (operationData.requestBody?.content) {
                                const requestSchema = this.extractRequestSchema(operationData.requestBody);
                                if (requestSchema) {
                                    schemas[`${method.toUpperCase()}_${path}_Request`] = requestSchema;
                                }
                            }

                            // Extract response schemas
                            if (operationData.responses) {
                                Object.entries(operationData.responses).forEach(([statusCode, response]) => {
                                    const responseData = response as any;
                                    if (responseData.content) {
                                        const responseSchema = this.extractResponseSchema(responseData);
                                        if (responseSchema) {
                                            schemas[`${method.toUpperCase()}_${path}_${statusCode}_Response`] = responseSchema;
                                        }
                                    }
                                });
                            }
                        }
                    });
                });
            }
        } catch (error) {
            console.warn('Failed to extract OpenAPI schemas:', error);
        }

        return schemas;
    }

    private extractRequestSchema(requestBody: any): any {
        try {
            // Look for JSON content first
            if (requestBody.content['application/json']?.schema) {
                return this.resolveOpenAPISchema(requestBody.content['application/json'].schema);
            }

            // Fallback to any content type
            for (const [contentType, content] of Object.entries(requestBody.content)) {
                const contentData = content as any;
                if (contentData.schema) {
                    return this.resolveOpenAPISchema(contentData.schema);
                }
            }
        } catch (error) {
            console.warn('Failed to extract request schema:', error);
        }
        return null;
    }

    private extractResponseSchema(response: any): any {
        try {
            // Look for JSON content first
            if (response.content['application/json']?.schema) {
                return this.resolveOpenAPISchema(response.content['application/json'].schema);
            }

            // Fallback to any content type
            for (const [contentType, content] of Object.entries(response.content)) {
                const contentData = content as any;
                if (contentData.schema) {
                    return this.resolveOpenAPISchema(contentData.schema);
                }
            }
        } catch (error) {
            console.warn('Failed to extract response schema:', error);
        }
        return null;
    }

    private resolveOpenAPISchema(schema: any): any {
        try {
            if (schema.$ref) {
                // Handle schema references
                const refPath = schema.$ref.replace('#/', '').split('/');
                let refSchema = this.openAPISpec;
                for (const path of refPath) {
                    refSchema = refSchema[path];
                }
                return this.resolveOpenAPISchema(refSchema);
            }

            if (schema.type === 'object' && schema.properties) {
                const resolvedSchema: any = { type: 'object', properties: {} };

                Object.entries(schema.properties).forEach(([propName, propSchema]) => {
                    resolvedSchema.properties[propName] = this.resolveOpenAPISchema(propSchema);
                });

                if (schema.required) {
                    resolvedSchema.required = schema.required;
                }

                return resolvedSchema;
            }

            if (schema.type === 'array' && schema.items) {
                return {
                    type: 'array',
                    items: this.resolveOpenAPISchema(schema.items)
                };
            }

            return schema;
        } catch (error) {
            console.warn('Failed to resolve OpenAPI schema:', error);
            return schema;
        }
    }

    private convertOpenAPISchemaToPOJO(schema: any): any {
        try {
            if (schema.type === 'object' && schema.properties) {
                const pojoSchema: any = { fields: [] };

                Object.entries(schema.properties).forEach(([fieldName, fieldSchema]) => {
                    const field = fieldSchema as any;
                    const isRequired = schema.required?.includes(fieldName) || false;

                    pojoSchema.fields.push({
                        name: fieldName,
                        type: this.mapOpenAPITypeToJava(field.type || 'string'),
                        required: isRequired,
                        description: field.description || ''
                    });
                });

                return pojoSchema;
            }

            return schema;
        } catch (error) {
            console.warn('Failed to convert OpenAPI schema to POJO:', error);
            return schema;
        }
    }

    private mapOpenAPITypeToJava(openAPIType: string): string {
        const typeMapping: Record<string, string> = {
            'string': 'String',
            'integer': 'Integer',
            'number': 'Double',
            'boolean': 'Boolean',
            'array': 'List<String>',
            'object': 'Object'
        };

        return typeMapping[openAPIType] || 'String';
    }

    // Enhanced schema detection for different sources
    private detectSchemaFromSource(endpoint: Endpoint, openAPISchemas?: Record<string, any>): any {
        // Priority 1: Use OpenAPI schema if available
        if (openAPISchemas) {
            const schemaKey = `${endpoint.method.toUpperCase()}_${endpoint.path}_Request`;
            const responseSchemaKey = `${endpoint.method.toUpperCase()}_${endpoint.path}_200_Response`;

            if (openAPISchemas[schemaKey]) {
                return {
                    source: 'openapi',
                    request: openAPISchemas[schemaKey],
                    response: openAPISchemas[responseSchemaKey] || null
                };
            }
        }

        // Priority 2: Use actual response data to infer schema
        if (endpoint.actualResponse?.data) {
            return {
                source: 'inferred',
                request: this.extractRequestDataFromResponse(endpoint),
                response: this.analyzeResponseData(endpoint.actualResponse.data)
            };
        }

        // Priority 3: Use provided request/response body
        if (endpoint.requestBody || endpoint.responseBody) {
            return {
                source: 'provided',
                request: endpoint.requestBody || {},
                response: endpoint.responseBody || {}
            };
        }

        // Priority 4: Generate default schemas
        return {
            source: 'default',
            request: this.generateDefaultRequestFields(endpoint),
            response: this.generateDefaultResponseFields(endpoint)
        };
    }

    private analyzeResponseData(responseData: any): any {
        try {
            if (typeof responseData === 'object' && responseData !== null) {
                const analyzedSchema: any = { fields: [] };

                Object.entries(responseData).forEach(([fieldName, fieldValue]) => {
                    const fieldType = this.inferFieldType(fieldValue);
                    const isComplex = this.isComplexField(fieldValue);

                    analyzedSchema.fields.push({
                        name: fieldName,
                        type: fieldType,
                        required: true, // Assume required for now
                        sampleValue: fieldValue,
                        isComplex: isComplex,
                        nestedSchema: isComplex ? this.analyzeNestedData(fieldValue, fieldName) : null
                    });
                });

                return analyzedSchema;
            }

            return { fields: [] };
        } catch (error) {
            console.warn('Failed to analyze response data:', error);
            return { fields: [] };
        }
    }

    private isComplexField(value: any): boolean {
        if (Array.isArray(value) && value.length > 0) {
            // Check if array contains objects
            return typeof value[0] === 'object' && value[0] !== null;
        }
        if (typeof value === 'object' && value !== null) {
            // Check if object has multiple properties
            return Object.keys(value).length > 1;
        }
        return false;
    }

    private analyzeNestedData(data: any, fieldName: string): any {
        if (Array.isArray(data) && data.length > 0) {
            // Analyze array of objects
            const firstItem = data[0];
            if (typeof firstItem === 'object' && firstItem !== null) {
                return {
                    type: 'array',
                    itemType: this.analyzeResponseData(firstItem),
                    className: this.sanitizeClassName(fieldName)
                };
            }
        } else if (typeof data === 'object' && data !== null) {
            // Analyze nested object
            return {
                type: 'object',
                fields: this.analyzeResponseData(data).fields,
                className: this.sanitizeClassName(fieldName)
            };
        }
        return null;
    }



    private inferFieldType(value: any): string {
        if (typeof value === 'string') return 'String';
        if (typeof value === 'number') return value % 1 === 0 ? 'Integer' : 'Double';
        if (typeof value === 'boolean') return 'Boolean';
        if (Array.isArray(value)) return 'List<String>';
        if (typeof value === 'object' && value !== null) return 'Object';
        return 'String';
    }

    private generateDefaultResponseFields(endpoint: Endpoint): any {
        // This method is a placeholder and should be implemented based on actual response data
        // For now, it returns a basic structure.
        return {
            id: 1,
            name: "Default Name",
            email: "default@example.com",
        };
    }

    private getSampleValueForType(type: string): any {
        switch (type) {
            case 'String': return 'sample_string';
            case 'Integer': return 123;
            case 'Double': return 123.45;
            case 'Boolean': return true;
            case 'List<String>': return ['item1', 'item2'];
            case 'Object': return { key: 'value' };
            default: return 'default_value';
        }
    }

    private convertSchemaToResponseData(schema: any): any {
        if (schema.fields && Array.isArray(schema.fields)) {
            const responseData: any = {};
            schema.fields.forEach((field: any) => {
                responseData[field.name] = this.getSampleValueForType(field.type);
            });
            return responseData;
        }
        return schema;
    }
}